---
title: data-structure
date: 2018-08-06 10:28:38
tags:
---



## vector

* 实质：可变长度的数组。
* 支持**随机存取**。随机存取：存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。也就是说数组是随机存取的，而链表就不是。

### 时间复杂度

| 操作          | 时间复杂度 |
| ------------- | ---------- |
| 读取第n位数据 | O(1)       |
|               |            |
|               |            |



### 空间分配策略

* `capacity` 返回该向量申请空间所能存放的元素个数。这个一般要大于size。
* `size` 返回当前元素个数。
* `max_size`返回能存放的最大个数。和电脑内存有关，如我的是1073741823

| 操作                     | size（个数） | capacity（个数） | 首元素地址 |
| ------------------------ | ------------ | ---------------- | ---------- |
| vector<int> int_vector;  | 0            | 0                |            |
| int_vector.push_back(1); | 1            | 1                | `0xfc15e8` |
| int_vector.push_back(2); | 2            | 2                | `0xfc15f8` |
| int_vector.push_back(3); | 3            | 4                | `0xfc1608` |
| int_vector.push_back(4); | 4            | 4                | `0xfc1608` |
| int_vector.push_back(5); | 5            | 8                | `0xfc1620` |
| int_vector.push_back(6); | 6            | 8                | `0xfc1620` |
| int_vector.push_back(7); | 7            | 8                | `0xfc1620` |

总结：

默认初始化时不分配空间；

空间不够时会申请现有元素两倍的新空间；

## list

实质：双向链表。

### 时间复杂度



## hash

数组的特点是：寻址容易，插入和删除困难；

链表的特点是：寻址困难，插入和删除容易。

那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？

参考：[十一、从头到尾解析Hash表算法](https://blog.csdn.net/v_july_v/article/details/6256463)

